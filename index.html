<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Benny Wong</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Benny Wong">
<meta property="og:url" content="http://gotobenny.com/index.html">
<meta property="og:site_name" content="Benny Wong">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Benny Wong">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Benny Wong" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img lazy-src="https://avatars3.githubusercontent.com/u/7565674?v=3&amp;s=460" class="js-avatar">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Benny Wong</a></h1>
		</hgroup>

		
		<p class="header-subtitle">足坛林黛玉</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Benny7" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/benny_wong" title="zhihu">zhihu</a>
					        
								<a class="douban" target="_blank" href="http://www.douban.com/people/benny-huang/" title="douban">douban</a>
					        
								<a class="mail" target="_blank" href="/gotobenny7@gmail.com" title="mail">mail</a>
					        
								<a class="facebook" target="_blank" href="https://www.facebook.com/bennywonghome" title="facebook">facebook</a>
					        
								<a class="twitter" target="_blank" href="https://twitter.com/BennyWong_7" title="twitter">twitter</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Algorithms/" style="font-size: 20px;">Algorithms</a> <a href="/tags/Base/" style="font-size: 10px;">Base</a> <a href="/tags/Computer-Graphics/" style="font-size: 10px;">Computer Graphics</a> <a href="/tags/Data-Structures/" style="font-size: 15px;">Data Structures</a> <a href="/tags/Lua/" style="font-size: 10px;">Lua</a> <a href="/tags/Math/" style="font-size: 10px;">Math</a> <a href="/tags/Network/" style="font-size: 10px;">Network</a> <a href="/tags/Operating-System/" style="font-size: 10px;">Operating System</a> <a href="/tags/STL/" style="font-size: 10px;">STL</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">程序猿，足球狗。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Benny Wong</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://avatars3.githubusercontent.com/u/7565674?v=3&amp;s=460" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Benny Wong</h1>
			</hgroup>
			
			<p class="header-subtitle">足坛林黛玉</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Benny7" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/benny_wong" title="zhihu">zhihu</a>
			        
						<a class="douban" target="_blank" href="http://www.douban.com/people/benny-huang/" title="douban">douban</a>
			        
						<a class="mail" target="_blank" href="/gotobenny7@gmail.com" title="mail">mail</a>
			        
						<a class="facebook" target="_blank" href="https://www.facebook.com/bennywonghome" title="facebook">facebook</a>
			        
						<a class="twitter" target="_blank" href="https://twitter.com/BennyWong_7" title="twitter">twitter</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-2018-02-25-data-type-and-structure" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/25/2018-02-25-data-type-and-structure/" class="article-date">
  	<time datetime="2018-02-25T15:41:00.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/2018-02-25-data-type-and-structure/">数据类型和数据结构</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>数据类型</strong>（data type）：强调数据的类型定义，即数据的存储和使用方式</p>
<pre><code>- <span class="keyword">*</span><span class="keyword">*</span>原子数据类型<span class="keyword">*</span><span class="keyword">*</span>（低层次抽象）：即需要关注数据的逻辑特征，也需要关注数据的物理特征
- <span class="keyword">*</span><span class="keyword">*</span>抽象数据类型<span class="keyword">*</span><span class="keyword">*</span>（高层次抽象）：只需要关注数据的逻辑特征，不需要关注数据的物理特征
</code></pre><p><strong>数据结构</strong>（data structure）：强调数据的结构，即数据的存储和组织方式<br>    即需要关注数据的逻辑结构，也需要关注数据的物理结构</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structures/">Data Structures</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2017-09-24-binary-search" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/24/2017-09-24-binary-search/" class="article-date">
  	<time datetime="2017-09-24T08:00:00.000Z" itemprop="datePublished">2017-09-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/24/2017-09-24-binary-search/">二分查找（binary search）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>二分查找</strong>是一种在有序表（逻辑结构上有序）查找特定元素的查找算法</p>
<h3 id="基本思想">基本思想</h3><p>查找过程中每次将查找范围缩小一半，直到最终确定是否存在目标元素</p>
<h3 id="伪代码">伪代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BINARY_SEARCH(A, v, s, e)</span><br><span class="line">	<span class="keyword">if</span> s &gt; e</span><br><span class="line">		<span class="built_in">return</span> None // 找不到目标元素</span><br><span class="line">	mid = (s + e) / <span class="number">2</span></span><br><span class="line">	<span class="keyword">if</span> A[mid] == v</span><br><span class="line">		<span class="built_in">return</span> mid // 找到目标元素</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> A[mid] &lt; v </span><br><span class="line">		BINARY_SEARCH(A, v, mid, e) // 目标元素在右边</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		BINARY_SEARCH(A, v, s, mid) // 目标元素在左边</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$T(n) = O(lgn)$</p>
<h3 id="理解">理解</h3><p>二分查找的关键在于快速定位中间值并缩小问题规模，所以像顺序表这种存储结构上有序的数据结构就很适合使用二分查找，链表由于无法快速定位中间值，所以不适合使用二分查找，顺序表虽然查找快速，但插入很慢，很多时候我们即需要高效的查找效率，同时也需要高效的插入和删除效率，这样一种即支持二分查找又拥有链式结构插入删除效率的数据结构就是<strong>二分查找树</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/">Algorithms</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2017-09-17-binary-tree" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/17/2017-09-17-binary-tree/" class="article-date">
  	<time datetime="2017-09-17T04:20:00.000Z" itemprop="datePublished">2017-09-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/17/2017-09-17-binary-tree/">二叉树（binary tree）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>二叉树</strong>是一种度最大为2的树，即每个节点最多只有两个子节点（左孩子，右孩子）的树</p>
<h3 id="特点">特点</h3><ul>
<li>二叉树的第i层最多有$2^{i-1}$个节点（等比数列）</li>
<li>二叉树最多有$2^k-1$个节点，其中k为深度（等比数列的和）</li>
</ul>
<h3 id="满二叉树（full_binary_tree）">满二叉树（full binary tree）</h3><p><strong>满二叉树</strong>是指节点度为0或为2的二叉树，即除了叶子节点其它节点的都有两个子节点的二叉树</p>
<h3 id="完全二叉树（complete_binary_tree）">完全二叉树（complete binary tree）</h3><p><strong>完全二叉树</strong>是指除了最后一层可以缺少右边节点，其它层达到最大节点的二叉树（总共有$2^{k-1}$到$2^k-1$个节点，其中k为深度）</p>
<h3 id="完美二叉树（perfect_binary_tree）">完美二叉树（perfect binary tree）</h3><p><strong>完美二叉树</strong>指每一层都达到最大节点的二叉树（总共有$2^k-1$个节点，其中k为深度）</p>
<h3 id="存储特点">存储特点</h3><p>完全二叉树和完美二叉树可以按顺序给每一个节点编号，所以相对于链式存储，顺序存储更适合完全二叉树和完美二叉树</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structures/">Data Structures</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2017-08-20-tree" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/08/20/2017-08-20-tree/" class="article-date">
  	<time datetime="2017-08-20T15:20:00.000Z" itemprop="datePublished">2017-08-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/20/2017-08-20-tree/">树（tree）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>树</strong>是一种抽象数据类型，用来模拟树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成的具有层次关系的集合，任何具有层次关系的问题都可以用树结构来表示。</p>
<h3 id="特点">特点</h3><ul>
<li>每个节点有n（n&gt;=0）个子节点</li>
<li>没有父节点的节点为为根节点</li>
<li>每一个非根节点都只有一个父节点</li>
<li>除了根节点外，每个子节点都可分为多个互不相交的子树</li>
</ul>
<h3 id="术语">术语</h3><ul>
<li><strong>度</strong>：节点的子树个数称为节点的度，最大节点的度称为树的度</li>
<li><strong>叶节点</strong>：度为0的节点</li>
<li><strong>分支节点</strong>：度不为0的节点</li>
<li><strong>高度</strong>：树中节点的最大层次称为树的高度</li>
<li><strong>森林</strong>：m（m&gt;=0）棵互不相交的树的集合</li>
<li><strong>节点关系</strong>：祖先，子孙，父节点，子节点，兄弟节点，堂兄弟节点</li>
</ul>
<h3 id="树的种类">树的种类</h3><ul>
<li><strong>无序树</strong>：子节点之间无顺序关系</li>
<li><strong>有序树</strong>：子节点之间有顺序关系</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structures/">Data Structures</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2017-03-23-xor-encryption" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/23/2017-03-23-xor-encryption/" class="article-date">
  	<time datetime="2017-03-23T15:20:00.000Z" itemprop="datePublished">2017-03-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/23/2017-03-23-xor-encryption/">异或加密（xor encryption）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>异或加密</strong>是一种基于异或运算的加密算法。</p>
<h3 id="基本思想">基本思想</h3><p>由于A xor B = C，C xor B = A，所以将明文A和秘钥B做异或运算可加密成密文C，将密文C和秘钥B做异或运算解密回明文A。</p>
<h3 id="伪代码">伪代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">XOR_ENCRYPTION(A, B) // 加密</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to B.length // 正向加密</span><br><span class="line">        <span class="keyword">for</span> j = <span class="number">1</span> to A.length</span><br><span class="line">            A[j] = A[j] ^ B[i] // 异或运算</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">XOR_DECRYPTION(A, B) // 解密</span><br><span class="line">	<span class="keyword">for</span> i = B.length to <span class="number">1</span> // 反向解密</span><br><span class="line">		<span class="keyword">for</span> j = <span class="number">1</span> to A.length</span><br><span class="line">			A[j] = A[j] ^ B[i] // 异或运算</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/">Algorithms</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-05-12-counting-sort" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/12/2015-05-12-counting-sort/" class="article-date">
  	<time datetime="2015-05-12T15:00:00.000Z" itemprop="datePublished">2015-05-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/12/2015-05-12-counting-sort/">计数排序（counting sort）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>计数排序</strong>是一种非基于比较的排序算法。</p>
<h3 id="基本思想">基本思想</h3><p>对输入序列中的某个元素x，统计不大于x的元素的个数n，则x就可直接放在第n+1个位置（$x \in [0, k]$）。</p>
<h3 id="图示">图示</h3><p><img src="/images/2015-05-12/counting-sort.png" alt="计数排序"></p>
<h3 id="伪代码">伪代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">COUNTING-SORT(A, B, k)</span><br><span class="line">    <span class="built_in">let</span> C[<span class="number">0</span>..k] be a new array</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to k</span><br><span class="line">        C[i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span> to A.length</span><br><span class="line">        C[A[j]] = C[A[j]] + <span class="number">1</span>   // 计算等于A[j]的个数</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to k</span><br><span class="line">        C[i] = C[i] + C[i - <span class="number">1</span>]  // 计算不大于A[j]的个数</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> j = A.length downto <span class="number">1</span></span><br><span class="line">        B[C[A[j]]] = A[j]       // 排序</span><br><span class="line">        C[A[j]] = C[A[j]] - <span class="number">1</span>   // 计数 - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度：$T(n) = O(n + k)$<br>当$k = O(n)$时，$T(n) = O(n)$</p>
<p>选择排序是稳定的排序算法。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/">Algorithms</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-04-18-hash-table" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/18/2015-04-18-hash-table/" class="article-date">
  	<time datetime="2015-04-18T15:00:00.000Z" itemprop="datePublished">2015-04-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/18/2015-04-18-hash-table/">散列表（hash table）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="直接寻址表">直接寻址表</h3><p><strong>直接寻址表</strong>（direct-address table）是对普通数组概念的推广，直接通过key访问表中的元素，当key的全域U比较小时，直接寻址是一种简单而有效的技术。<br><img src="/images/2015-04-18/direct-address-table.png" alt="直接寻址表"></p>
<h3 id="散列表">散列表</h3><p>直接寻址表的缺点很明显：当key的全域U很大时，表的大小|U|就会占用很大存储空间。</p>
<p><strong>散列</strong>（hash）的原意是随机混杂和拼凑，在计算机科学中是一种极其有效和实用的技术，此技术通过<strong>散列函数</strong>，将任意长度的输入，转换为固定长度的输出（散列值）。这种转换是一种<strong>压缩映射</strong>（输出空间远小于输入空间）。</p>
<p><strong>散列表</strong>（hash table）是借助散列技术实现字典操作（INSERT，SEARCH，DELETE）的一种数据结构，用散列表替代直接数组寻址（通过散列函数将key映射到存储位置，即<strong>槽</strong>（slot）），使得可以在$O(1)$时间内访问表中的任意位置。</p>
<h3 id="冲突">冲突</h3><p><strong>冲突</strong>（collision）：指两个key映射到同一个slot上的情况<br>解决冲突：有两种方法可以用来解决冲突，一种是<strong>链接法</strong>（chaining），另一种是<strong>开放寻址法</strong>（open addressing）</p>
<h3 id="散列函数">散列函数</h3><ul>
<li><strong>除法散列函数</strong>（启发式方法）<br>$h(k) = k\ mod\ m$</li>
<li><strong>乘法散列函数</strong>（启发式方法）<br>$h(k) = \lfloor m(kA\ mod\ 1)\rfloor $</li>
<li><strong>全域散列函数</strong>（随机化技术）<br>随机选择散列函数，使之独立于存储的关键字</li>
</ul>
<h3 id="链接法">链接法</h3><p>在链接法中，散列到同一个slot上的元素都存储到一个链表中，并将链表表头存储到slot中<br><img src="/images/2015-04-18/hash-table.png" alt="散列表"></p>
<h3 id="开放寻址法">开放寻址法</h3><p>在开放寻址法中，所有的元素都存储在散列表里，每个表项要么为NIL要么包含动态集合的一个元素，当查找某元素时，会探查所有表项，直到找到目标元素或最终查明目标元素不在表中。在开放寻址法中，散列表可能会被填满。</p>
<p><strong>探查序列</strong>（probe sequence）：$(\ h(k,0),h(k, 1),…,h(k, m-1)\ )$，即$(\ 0,1,…,m-1\ )$的一个排列。</p>
<p>有三种技术常用来技术开放寻址法中的探查序列：<strong>线性探查</strong>（linear probing），<strong>二次探查</strong>（quadratic probing）和<strong>双重探查</strong>（double probing）</p>
<ul>
<li><p>线性探查<br>散列函数：$h(k,i) = (h_1(k) + i)\ mod\ m, i = 0, 1, …, m-1$<br>线性探查会首先探查槽$T[h_1(k)]$，接着探查槽$T[h_1(k) + 1]$，直到到达槽$T[h_1(k) - 1]$，故线性探查只有$m$种探查序列。线性探查存在一个称之为一次群集（primary clustering）的问题，即随着连续被占用的槽不断增加，平均查找时间会随之增加。</p>
</li>
<li><p>二次探查<br>散列函数：$h(k,i) = (h_1(k) + c_1 i + c_2 i^2)\ mod\ m, i = 0, 1, …, m-1$<br>二次探查会首先探查槽$T[h_1(k)]$,之后的探查位置会增加一个偏移量，该偏移量以二次的方式依赖于探查号$i$，这种探查的效果比线性探查要好得多，二次探查同样只有$m$种探查序列。</p>
</li>
<li><p>双重探查<br>散列函数：$h(k,i) = (h_1(k) + i h_2(k))\ mod\ m, i = 0, 1, …, m-1$<br>其中$h_1(k) = k\ mod\ m, h_2(k) = 1 + (k\ mod\ m_0), m_0略小于m$<br>双重散列是用于开放寻址法的最好方法之一，双重散列有$m^2$种探查序列，其性能非常接近理想的均匀散列的性能</p>
</li>
</ul>
<h3 id="完全散列">完全散列</h3><p>待续</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structures/">Data Structures</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-04-08-lua-start" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/08/2015-04-08-lua-start/" class="article-date">
  	<time datetime="2015-04-08T15:00:00.000Z" itemprop="datePublished">2015-04-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/08/2015-04-08-lua-start/">Lua</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>Lua</strong>是一个简洁，轻量，可扩展的脚本语言。其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p>
<h3 id="Lua源码结构">Lua源码结构</h3><ul>
<li><p><strong>虚拟机核心功能</strong><br>lapi.c lctype.c ldebug.c ldo.c lfunc.c lgc.c lmem.c lobject.c lopcodes.c lstate.c lstring.c ltable.c ltm.c lvm.c lzio.c</p>
</li>
<li><p><strong>源码解析及预编译字节码</strong><br>lcode.c ldump.c llex.c lparser.c lunddump.c</p>
</li>
<li><p><strong>内嵌库</strong><br>lauxlib.c lbaselib.c lbitlib.c lcorolib.c ldblib.c linit.c liolib.c lmathlib.c loadlib.c loslib.c lstrlib.c ltablib.c</p>
</li>
<li><p><strong>可执行文件</strong><br>lua.c（解析器） luac.c（编译器）</p>
</li>
</ul>
<h3 id="Building_lua_on_windows">Building lua on windows</h3><p>在virtual studio中创建以下3个项目</p>
<ol>
<li><strong>链接库</strong>：虚拟机核心功能，源码解析及预编译字节码，内嵌库</li>
<li><strong>解析</strong>：解析器，依赖链接库</li>
<li><strong>编译</strong>：编译器，依赖链接库</li>
</ol>
<p>待续</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/">Lua</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-03-25-tcp-ip" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/26/2015-03-25-tcp-ip/" class="article-date">
  	<time datetime="2015-03-25T17:00:00.000Z" itemprop="datePublished">2015-03-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/26/2015-03-25-tcp-ip/">TCP/IP协议</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p><strong>TCP（Transmission Control Protocol，传输控制协议）</strong><br>负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。</p>
</li>
<li><p><strong>IP（Internet Protocol，网际协议）</strong><br>给因特网的每一台联网设备规定一个地址。</p>
</li>
<li><p><strong>UDP（User Datagram Protocol，用户数据报协议）</strong></p>
</li>
<li><p><strong>ICMP（Internet Control Message Protocol，互联网控制信息协议）</strong></p>
</li>
<li><p><strong>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）</strong></p>
</li>
<li><p><strong>SNMP（Simple Network manage Protocol，简单网络管理协议）</strong></p>
</li>
<li><p><strong>FTP（File Transfer Protocol，文件传输协议）</strong></p>
</li>
<li><p><strong>ARP（Address Resolation Protocol，地址解析协议）</strong></p>
</li>
</ul>
<p>从协议分层模型方面来讲，TCP/IP由四个层次组成：</p>
<ol>
<li>网络接口层</li>
<li>网间层</li>
<li>传输层</li>
<li>应用层</li>
</ol>
<h3 id="3次握手（three-way_handshake）">3次握手（three-way handshake）</h3><p><img src="/images/2015-03-26/tcp-ip-handshake.png" alt="3次握手"><br><strong>SYN</strong>（synchronous）：请求同步，建立连接<br><strong>ACK</strong>（acknowledgement）：传输确认，响应请求</p>
<h3 id="4次挥手（four-way_wavehand）">4次挥手（four-way wavehand）</h3><p><img src="/images/2015-03-26/tcp-ip-wavehand.png" alt="4次挥手"></p>
<p><strong>FIN</strong>（finish）：关闭连接</p>
<h3 id="Socket">Socket</h3><p>建立Socket连接至少需要一对套接字，其中一个运行于客户端，另一个运行于服务端。</p>
<ol>
<li>服务端监听<br>服务端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</li>
<li>客户端请求<br>客户端的套接字提出连接请求，要连接的目标是服务端的套接字。</li>
<li>连接确认<br>当服务端套接字接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。<br><img src="/images/2015-03-27/socket.png" alt="Socket"></li>
</ol>
<p><img src="/images/2015-03-27/socket-connect.png" alt="Socket Connect"></p>
<h3 id="TCP和UDP的区别">TCP和UDP的区别</h3><ol>
<li><p>TCP面向连接，UDP面向无连接<br>TCP传送数据前建立，保证连接的可靠性（3次握手4次挥手），UDP传送数据前不建立连接，接收数据后也不发送确认信号，不保证可靠性。</p>
</li>
<li><p>UDP更轻量<br>UDP的开销更小数据传输速率更高，因为不必进行收发数据的确认，所以UDP的实时性更好。</p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Network/">Network</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-03-25-recursion-iteration" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/25/2015-03-25-recursion-iteration/" class="article-date">
  	<time datetime="2015-03-25T07:00:00.000Z" itemprop="datePublished">2015-03-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/25/2015-03-25-recursion-iteration/">递归和迭代</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>递归</strong>（recursion）：递归常被用来描述以自相似方法重复事物的过程，在数学和计算机科学中，指的是在函数定义中使用函数自身的方法。（A调用A）<br><strong>迭代</strong>（iteration）：重复反馈过程的活动，每一次迭代的结果会作为下一次迭代的初始值。（A重复调用B）</p>
<h3 id="递归和迭代的区别：">递归和迭代的区别：</h3><p>递归是一个<strong>树结构</strong>，从字面可以其理解为重复“递推”和“回归”的过程，当“递推”到达底部时就会开始“回归”，其过程相当于树的深度优先遍历。</p>
<p>迭代是一个<strong>环结构</strong>，从初始状态开始，每次迭代都遍历这个环，并更新状态，多次迭代直到到达结束状态。</p>
<p>理论上递归和迭代时间复杂度方面是一样的，但实际应用中（函数调用和函数调用堆栈的开销）递归比迭代效率要低。</p>
<p><img src="/images/2015-03-25/recursion-iteration.png" alt="递归和迭代"></p>
<h3 id="递归转迭代">递归转迭代</h3><p>理论上递归和迭代可以相互转换，但实际从算法结构来说，递归声明的结构并不总能转换为迭代结构（原因在于结构的引申本身属于递归的概念，用迭代的方法在设计初期根本无法实现）。迭代可以转换为递归，但递归不一定能转换为迭代。</p>
<p>将递归算法转换为非递归算法有两种方法，一种是直接求值（迭代），不需要回溯；另一种是不能直接求值，需要回溯。前者使用一些变量保存中间结果，称为直接转换法，后者使用栈保存中间结果，称为间接转换法。</p>
<ul>
<li><p><strong>直接转换法</strong><br>直接转换法通常用来消除<strong>尾递归</strong>（tail recursion）和<strong>单向递归</strong>，将递归结构用迭代结构来替代。（单向递归 → 尾递归 → 迭代）</p>
</li>
<li><p><strong>间接转换法</strong><br>递归实际上利用了系统堆栈实现自身调用，我们通过使用栈保存中间结果模拟递归过程，将其转为非递归形式。</p>
</li>
</ul>
<p>尾递归函数递归调用返回时正好是函数的结尾，因此递归调用时就不需要保留当前栈帧，可以直接将当前栈帧覆盖掉。</p>
<p><img src="/images/2015-03-25/tail-recursion.png" alt="尾递归"></p>
<h3 id="斐波那契数列">斐波那契数列</h3><h5 id="递归形式">递归形式</h5><p>斐波那契数列递归式：$F(n) = F(n - 1) + F(n - 2) (n &gt;= 2)$</p>
<p>伪代码（递归算法）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FOB_RECURSION(n)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> or n == <span class="number">2</span></span><br><span class="line">        <span class="built_in">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">return</span> FOB_RECURSION(n - <span class="number">1</span>) + FOB_RECURSION(n - <span class="number">2</span>) // 调用自身</span><br></pre></td></tr></table></figure></p>
<h5 id="非递归形式">非递归形式</h5><p><strong>直接转换：</strong><br>斐波那契数列迭代式：$x_n = f(x_a, x_b) (a = n-1, b = n-2, n &gt;= 2)$</p>
<p>伪代码（迭代算法）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FOB_ITERATION(n)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> or n == <span class="number">2</span></span><br><span class="line">        <span class="built_in">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fn1 = <span class="number">1</span> // 初始状态</span><br><span class="line">        fn2 = <span class="number">1</span> // 初始状态</span><br><span class="line">        fn = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i = <span class="number">2</span> to n  // 迭代</span><br><span class="line">            fn = fn1 + fn2</span><br><span class="line">            fn1 = fn2</span><br><span class="line">            fn2 = fn</span><br><span class="line">        <span class="built_in">return</span> fn</span><br></pre></td></tr></table></figure></p>
<p><strong>间接转换框架：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION()</span><br><span class="line">    stack.push(s0) // s0：初始状态</span><br><span class="line">    <span class="keyword">while</span> !stack.empty()</span><br><span class="line">        s = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> isSolution(s)</span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        <span class="keyword">else</span> stack.push(s1) // s1：相关状态</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Base/">Base</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-03-24-stl-container" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/24/2015-03-24-stl-container/" class="article-date">
  	<time datetime="2015-03-24T15:00:00.000Z" itemprop="datePublished">2015-03-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/24/2015-03-24-stl-container/">STL容器</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="容器种类">容器种类</h3><p>标准STL序列容器：vector（数组），string（数组），deque（数组），list（双向循环链表）<br>标准STL关联容器：set（红黑树），multiset（红黑树），map（红黑树），multimap（红黑树）<br>非标准序列容器：slist（单向链表），rope<br>非标准关联容器：hash_set（散列表），hash_multiset（散列表），hash_map（散列表），hash_multimap（散列表）<br>标准非STL容器：数组，bitset，valarray，stack（双端队列），queue（双端队列），priority_queue（堆）</p>
<h3 id="容器分类">容器分类</h3><ul>
<li>连续内存容器（contiguous-memory container）</li>
<li>基于节点的容器（node-based container）</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/STL/">STL</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-03-22-pipeline" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/22/2015-03-22-pipeline/" class="article-date">
  	<time datetime="2015-03-22T15:00:00.000Z" itemprop="datePublished">2015-03-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/22/2015-03-22-pipeline/">OpenGL编程管线</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="基本概念">基本概念</h3><ul>
<li><strong>图元</strong>（entity）：组成图像的基本单元（点，直线，多边形，图形，位图）</li>
<li><strong>片元</strong>（primitive）：像素点（像素，位置，法向量等）</li>
</ul>
<h3 id="OpenGL编程管线">OpenGL编程管线</h3><p><img src="/images/2015-03-22/pipeline.png" alt="OpenGL编程管线"></p>
<ul>
<li><p><strong>指定几何对象</strong></p>
</li>
<li><p><strong>顶点处理</strong>（Vectex Shader）<br>顶点（位置，纹理坐标，颜色）</p>
</li>
<li><p><strong>图元装配</strong>（Geometry Shader）<br>组装图元</p>
</li>
<li><p><strong>图元处理</strong><br>裁剪，消隐</p>
</li>
<li><p><strong>栅格化</strong><br>图元数据栅格化为片元</p>
</li>
<li><p><strong>片元处理</strong>（Fragment Shader）<br>处理像素颜色</p>
</li>
<li><p><strong>逐个片元操作</strong><br>剪切（glScissor），Alpha测试（glAlphaFunc），模版测试（glStencilFunc），深度测试（glDephtFunc），混合（glBlendFunc）</p>
</li>
<li><p><strong>帧缓冲操作</strong><br>帧缓冲写入</p>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Graphics/">Computer Graphics</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-03-21-virtual-address-space" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/21/2015-03-21-virtual-address-space/" class="article-date">
  	<time datetime="2015-03-21T04:00:00.000Z" itemprop="datePublished">2015-03-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/21/2015-03-21-virtual-address-space/">虚拟地址空间</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="物理内存">物理内存</h3><p>物理内存条的内存空间。</p>
<h3 id="虚拟内存">虚拟内存</h3><p><strong>虚拟内存</strong>（virtual memory）是计算机系统内存管理的一种技术。它将多个物理内存碎片和部分磁盘空间重定义为连续的地址空间，以此让程序认为自己拥有连续可用的内存。当物理内存不足时，操作系统会将处于不活动状态的程序以及它们的数据全部交换到磁盘上来释放物理内存，以供其它程序使用。</p>
<h3 id="虚拟地址空间">虚拟地址空间</h3><p>在多任务操作系统中，每个进程都运行在属于自己的内存沙盘中，这个沙盘就是<strong>虚拟地址空间</strong>（virtual address space）。虚拟地址空间由<strong>内核空间</strong>（kernel space）和<strong>用户模式空间</strong>（user mode space）两部分组成。<br>虚拟地址会通过<strong>页表</strong>（page table）映射到物理内存，页表由操作系统维护并被处理器引用，每个进程都有自己的页表。内核空间在页表中拥有较高特权级，因此用户态程序试图访问这些页是会导致一个<strong>页错误</strong>（page fault）。其中内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存。与此相反，用户模式空间的映射随进程切换的发生而不断变化。</p>
<p><img src="/images/2015-03-21/virtual-address-space.png" alt="虚拟地址空间"></p>
<h3 id="进程内存布局">进程内存布局</h3><p>进程内存空间通过<strong>分段存储</strong>来管理。</p>
<p><img src="/images/2015-03-21/memory-layout.png" alt="进程内存布局"></p>
<ul>
<li><p><strong>内核空间</strong>（kernel space）<br>内核总是驻留在内存中，是操作系统的一部分。内核空间为内核保留，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。</p>
</li>
<li><p><strong>环境变量</strong>（environment variables）</p>
</li>
<li><p><strong>命令行参数</strong>（command-line arguments）</p>
</li>
<li><p><strong>栈</strong>（stack）<br>栈又称堆栈，由编译器自动分配释放，行为类似数据结构中的栈（先进后出）。栈用来存储临时数据和栈帧。</p>
</li>
<li><p><strong>内存映射段</strong>（memory mapping segment）<br>将硬盘文件的内容直接映射到内存，内存映射是一种方便高效的文件I/O方式， 因而被用于装载动态共享库。</p>
</li>
<li><p><strong>堆</strong>（heap）<br>堆用于存放进程运行时动态分配的内存段。</p>
</li>
<li><p><strong>BSS段</strong>（bss segment）<br>静态内存分配，保存未初始化的全局及静态变量（皆为0），可读可写。</p>
</li>
<li><p><strong>数据段</strong>（data segment）<br>静态内存分配，保存已初始化的全局及静态变量，可读可写。</p>
</li>
<li><p><strong>代码段</strong>（text segment）<br>保存可执行机器码和常量，可读不可写可执行。</p>
</li>
<li><p><strong>保留区</strong>（reserved）<br>位于虚拟地址空间的最低部分，未赋予物理地址。任何对它的引用都是非法的，用于捕捉使用空指针和小整型值指针引用内存的异常情况。<br>它并不是一个单一的内存区域，而是对地址空间中受到操作系统保护而禁止用户进程访问的地址区域的总称。大多数操作系统中，极小的地址通常都是不允许访问的，如NULL。</p>
</li>
</ul>
<h3 id="虚拟地址到物理地址的映射">虚拟地址到物理地址的映射</h3><p><img src="/images/2015-03-21/virtual-address.png" alt="进程内存布局"></p>
<h3 id="分段机制">分段机制</h3><p>分段机制将虚拟地址转换为线性地址。分段机制的引入是为了提高可寻址的物理地址空间大小。</p>
<ul>
<li><strong>实模式</strong><br>寻址方式：<strong>段基址:段内偏移 = 段基址*16 + 段内偏移</strong></li>
<li><strong>保护模式</strong><br>寻址方式：<strong>段选择符:段内偏移 = 段基址:段内偏移 = 段基址*16 + 段内偏移</strong><br><strong>段描述符</strong>：包含一个段的完整描述，包括段的基址，段的限长和段的属性。<br><strong>段描述符表</strong>：全局描述符表（GDT），局部描述符表（LDT），中断描述符表（IDT）<br><strong>全局描述符表</strong>（GDT）：操作系统中特殊的数据结构，并且由处理器的内存管理硬件来引用，每一个CPU都要有一个GDT。<br><strong>局部描述符表</strong>（LDT）：操作系统中特殊的数据结构，每个任务可以定义一个LDT，存放该任务的代码段、数据段等<br><strong>段选择符</strong>：每个段都有一个段选择符。段描述符指明段的大小、访问权限和段的特权级、段类型以及段的第一个字节在线性地址空间中的位置（段基地址）。而段选择符用于在描述符表中进行索引找到段描述符。</li>
</ul>
<p><img src="/images/2015-03-21/segment.png" alt="分段机制"></p>
<h3 id="分页机制">分页机制</h3><p>将每个段被划分成页面（通常每页4KB），页面会被存储于物理内存或硬盘上。如果禁用分页机制，那么线性地址空间就是物理地址空间。<br><strong>线性地址 = 页目录 : 页号 : 页内偏移</strong></p>
<p><img src="/images/2015-03-21/page.png" alt="分页机制"></p>
<h3 id="内存管理单元">内存管理单元</h3><p><strong>内存管理单元</strong>（memory management unit，MMU）是一种负责处理中央处理器（CPU）的内存访问请求的计算机硬件，它的功能包括虚拟地址到物理地址的转换（即<strong>虚拟内存管理</strong>）、内存保护、中央处理器高速缓存的控制。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Operating-System/">Operating System</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-03-19-linked-list" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/19/2015-03-19-linked-list/" class="article-date">
  	<time datetime="2015-03-19T15:00:00.000Z" itemprop="datePublished">2015-03-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/19/2015-03-19-linked-list/">链表（linked list）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>链表</strong>是一种动态集合，其中的对象按线性顺序排列，链表的顺序由对象中的指针决定。</p>
<h3 id="链表的作用">链表的作用</h3><p>链表使对象之间的逻辑顺序独立于对象之间的物理顺序，使得动态分配内存和插入删除操作变得很容易。</p>
<h3 id="链表的形式">链表的形式</h3><ul>
<li><strong>单链表</strong>（singly linked list）：节点包含key，next（表尾next为nil）</li>
<li><strong>双向链表</strong>（doublylinked list）：节点包含key，next，prev（表尾next和表头prev为nil）</li>
<li><strong>循环链表</strong>（circular linked list）：节点包含key，next，prev（表尾next指向哨兵sentinel）</li>
</ul>
<h3 id="链表的操作">链表的操作</h3><ol>
<li>LSIT-SEARCH(L, k)：搜索</li>
<li>LSIT-INSERT(L, x)：插入，一般在队头插入</li>
<li>LSIT-DELETE(L, x)：删除</li>
</ol>
<p><strong>时间复杂度：</strong></p>
<table>
<thead>
<tr>
<th><strong>形式</strong></th>
<th style="text-align:center"><strong>SEARCH</strong></th>
<th style="text-align:center"><strong>INSERT</strong></th>
<th style="text-align:center"><strong>DELETE</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>单链表</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">$O(n)$</td>
</tr>
<tr>
<td>双向链表</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">$O(1)$</td>
</tr>
<tr>
<td>循环链表</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">$O(1)$</td>
</tr>
</tbody>
</table>
<h3 id="链表的模型">链表的模型</h3><p><img src="/images/2015-03-19/singly-linked-list.png" alt="单链表"><br><img src="/images/2015-03-19/doubly-linked-list.png" alt="双向链表"><br><img src="/images/2015-03-19/circular-linked-list.png" alt="循环链表"></p>
<h3 id="伪代码">伪代码</h3><h5 id="双向链表：">双向链表：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LSIT-SEARCH(L, k)</span><br><span class="line">    x = L.head</span><br><span class="line">    <span class="keyword">while</span> x != NIL and x.key != k</span><br><span class="line">        x = x.next</span><br><span class="line">    <span class="built_in">return</span> x</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LSIT-INSERT(L, x)</span><br><span class="line">    x.next = L.head // 新节点后继指向表头</span><br><span class="line">    <span class="keyword">if</span> L.head != NIL</span><br><span class="line">        L.head.prev = x // 表头前驱指向新节点</span><br><span class="line">    L.head = x // 新节点成为表头</span><br><span class="line">    x.prev = NIL</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LSIT-DELETE(L, x)</span><br><span class="line">    <span class="keyword">if</span> x.prev != NIL</span><br><span class="line">        x.prev.next = x.next // 让x的后继成为x前驱的后继</span><br><span class="line">    <span class="keyword">else</span> L.head = x.next // 让x的后继成为表头</span><br><span class="line">    <span class="keyword">if</span> x.next != NIL</span><br><span class="line">        x.next.prev = x.prev // 让x的前驱成为x后继的前驱</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="循环链表：">循环链表：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LSIT-SEARCH<span class="string">'(L, k)</span><br><span class="line">    x = L.nil.next</span><br><span class="line">    while x != L.nil and x.key != k</span><br><span class="line">        x = x.next</span><br><span class="line">    return x</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LSIT-INSERT<span class="string">'(L, x)</span><br><span class="line">    x.next = L.nil.next // 新节点后继指向表头</span><br><span class="line">    L.nil.next.prev = x // 表头前驱指向新节点</span><br><span class="line">    L.nil.next = x // 新节点成为表头</span><br><span class="line">    x.prev = L.nil // 新节点前驱指向哨兵</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LSIT-DELETE<span class="string">'(L, x)</span><br><span class="line">    x.prev.next = x.next // 让x的后继成为x前驱的后继</span><br><span class="line">    x.next.prev = x.prev // 让x的前驱成为x后继的前驱</span></span><br></pre></td></tr></table></figure>
<h3 id="用数组表示链表">用数组表示链表</h3><p><strong>多数组：</strong><br><img src="/images/2015-03-19/linked-list-array-muilty.png" alt="多数组"></p>
<p><strong>单数组：</strong><br><img src="/images/2015-03-19/linked-list-array-single.png" alt="单数组"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structures/">Data Structures</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-03-19-priority-queue" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/19/2015-03-19-priority-queue/" class="article-date">
  	<time datetime="2015-03-19T09:00:00.000Z" itemprop="datePublished">2015-03-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/19/2015-03-19-priority-queue/">优先队列（priority queue）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>优先队列</strong>是一种抽象数据类型，这种队列中的每个元素都有各自的优先级。和普通队列先进先出不同，优先队列实现的是最高级先出（largest-in，first-out）。优先队列通常用<strong>堆</strong>来实现。</p>
<h3 id="优先队列的形式">优先队列的形式</h3><ul>
<li><strong>最大优先队列</strong>：共享计算机系统的作业调度</li>
<li><strong>最小优先队列</strong>：基于事件驱动的模拟器</li>
</ul>
<h3 id="图示">图示</h3><p><img src="/images/2015-03-19/priority-queue.png" alt="优先队列"></p>
<h3 id="最大优先队列的基本过程">最大优先队列的基本过程</h3><ul>
<li>MAX-HEAPIFY(A, i)：维护最大堆性质（$O(lgn)$）</li>
<li>BUILD-MAX-HEAP(A)：从无序数组中构建最大堆（$O(n)$）</li>
<li>HEAP-MAXIMUM(A)：获取最大堆的最大元素（根节点）（$O(1)$）</li>
<li>HEAP-EXTRACT-MAX(A)：移除最大堆的最大元素（根节点）（$O(lgn)$）</li>
<li>HEAP-INCREASE-KEY(A, i, key)：将节点i的元素提高到keyv（$O(lgn)$）</li>
<li>MAX-HEAP-INSERT(A, key)：插入元素key（$O(lgn)$）</li>
</ul>
<h3 id="伪代码（最大优先队列）">伪代码（最大优先队列）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MAX-HEAPIFY(A, i)</span><br><span class="line">    l = LEFT(i)</span><br><span class="line">    r = RIGHT(i)</span><br><span class="line">    <span class="keyword">if</span> l &lt;= A.heap-size and A[l] &gt; A[i]</span><br><span class="line">        largest = l // 找出i, <span class="number">2</span>i, <span class="number">2</span>i + <span class="number">1</span>元素最大那个</span><br><span class="line">    <span class="keyword">else</span> largest = i // 找出i, <span class="number">2</span>i, <span class="number">2</span>i + <span class="number">1</span>元素最大那个</span><br><span class="line">    <span class="keyword">if</span> r &lt;= A.heap-size and A[r] &gt; A[largest]</span><br><span class="line">        largest = r // 找出i, <span class="number">2</span>i, <span class="number">2</span>i + <span class="number">1</span>元素最大那个</span><br><span class="line">    <span class="keyword">if</span> largest != i // 维护最大堆性质</span><br><span class="line">        exchange A[i] with A[largest]</span><br><span class="line">        MAX-HEAPIFY(A, largest)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BUILD-MAX-HEAP(A)</span><br><span class="line">    A.heap-size = A.length</span><br><span class="line">    <span class="keyword">for</span> i = A.length / <span class="number">2</span> downto <span class="number">1</span> // 自底向上维护最大堆性质</span><br><span class="line">        MAX-HEAPIFY(A, i)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HEAP-MAXIMUM(A)</span><br><span class="line">    <span class="built_in">return</span> A[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HEAP-EXTRACT-MAX</span><br><span class="line">    <span class="keyword">if</span> A.heap-size &lt; <span class="number">1</span></span><br><span class="line">        error <span class="string">"heap underflow"</span></span><br><span class="line">    max = A[<span class="number">1</span>]</span><br><span class="line">    A[<span class="number">1</span>] = A[A.heap-size] // 用堆最后的元素覆盖根节点</span><br><span class="line">    A.heap-size = A.heap-size - <span class="number">1</span></span><br><span class="line">    MAX-HEAPIFY(A, <span class="number">1</span>)  // 维护最大堆性质</span><br><span class="line">    <span class="built_in">return</span> max</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HEAP-INCREASE-KEY(A, i, key)</span><br><span class="line">    <span class="keyword">if</span> key &lt; A[i]</span><br><span class="line">        error <span class="string">"new key is smaller than current key"</span></span><br><span class="line">    A[i] = key</span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">1</span> and A[PARENT(i)] &lt; A[i] // 不满足最大堆性质</span><br><span class="line">        exchange A[i] whith A[PARENT(i)]</span><br><span class="line">        i = PARENT(i)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MAX-HEAP-INSERT(A, key)</span><br><span class="line">    A.heap-size = A.heap-size + <span class="number">1</span></span><br><span class="line">    A[A.heap-size] = -infinity</span><br><span class="line">    HEAP-INCREASE-KEY(A, A.heap-size, key)</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/">Algorithms</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-03-19-heap-sort" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/19/2015-03-19-heap-sort/" class="article-date">
  	<time datetime="2015-03-19T07:00:00.000Z" itemprop="datePublished">2015-03-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/19/2015-03-19-heap-sort/">堆排序（heap sort）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>堆排序</strong>是利用<strong>堆积树</strong>（<strong>堆</strong>）这种数据结构所设计的排序算法。本质上堆排序是<strong>选择排序</strong>的一种。</p>
<h3 id="堆">堆</h3><p>堆（<strong>二叉堆</strong>）是一个数组，可以被看成近似的<strong>完全二叉树</strong>，树点对应数组元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PARENT(i) // 获取父节点</span><br><span class="line">    <span class="built_in">return</span> i / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">LEFT(i) // 获取左孩子</span><br><span class="line">    <span class="built_in">return</span> <span class="number">2</span>i</span><br><span class="line"></span><br><span class="line">RIGHT(i) // 获取右孩子</span><br><span class="line">    <span class="built_in">return</span> <span class="number">2</span>i + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>图示：<br><img src="/images/2015-03-19/heap-sort.png" alt="堆"></p>
<h3 id="堆的形式">堆的形式</h3><ul>
<li><strong>最大堆</strong>（满足<strong>最大堆性质</strong>）<br>除根外所有节点i满足：A[PARENT(i)] &gt;= A[i]</li>
<li><strong>最小堆</strong>（满足<strong>最小堆性质</strong>）<br>除根外所有节点i满足：A[PARENT(i)] &lt;= A[i]</li>
</ul>
<h3 id="堆排序的基本过程（最大堆）">堆排序的基本过程（最大堆）</h3><ul>
<li>MAX-HEAPIFY(A, i)：维护最大堆性质（$O(lgn)$）</li>
<li>BUILD-MAX-HEAP(A)：从无序数组中构建最大堆（$O(n)$）</li>
<li>HEAP-SORT(A)：进行原址排序（$O(nlgn)$）</li>
</ul>
<h3 id="维护堆的性质">维护堆的性质</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MAX-HEAPIFY(A, i)</span><br><span class="line">    l = LEFT(i)</span><br><span class="line">    r = RIGHT(i)</span><br><span class="line">    <span class="keyword">if</span> l &lt;= A.heap-size and A[l] &gt; A[i]</span><br><span class="line">        largest = l // 找出i, <span class="number">2</span>i, <span class="number">2</span>i + <span class="number">1</span>元素最大那个</span><br><span class="line">    <span class="keyword">else</span> largest = i // 找出i, <span class="number">2</span>i, <span class="number">2</span>i + <span class="number">1</span>元素最大那个</span><br><span class="line">    <span class="keyword">if</span> r &lt;= A.heap-size and A[r] &gt; A[largest]</span><br><span class="line">        largest = r // 找出i, <span class="number">2</span>i, <span class="number">2</span>i + <span class="number">1</span>元素最大那个</span><br><span class="line">    <span class="keyword">if</span> largest != i // 维持最大堆性质</span><br><span class="line">        exchange A[i] with A[largest]</span><br><span class="line">        MAX-HEAPIFY(A, largest)</span><br></pre></td></tr></table></figure>
<h3 id="建堆">建堆</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BUILD-MAX-HEAP(A)</span><br><span class="line">    A.heap-size = A.length</span><br><span class="line">    <span class="keyword">for</span> i = A.length / <span class="number">2</span> downto <span class="number">1</span> // 自底向上维护最大堆性质</span><br><span class="line">        MAX-HEAPIFY(A, i)</span><br></pre></td></tr></table></figure>
<h3 id="堆排序">堆排序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HEAP-SORT(A)</span><br><span class="line">    BUILD-MAX-HEAP(A) // 建堆</span><br><span class="line">    <span class="keyword">for</span> i = A.length downto <span class="number">2</span> // 将根移除移到数组末端（排序）</span><br><span class="line">        exchange A[<span class="number">1</span>] with A[i]</span><br><span class="line">        A.heap-size = A.heap-size - <span class="number">1</span></span><br><span class="line">        MAX-HEAPIFY(A, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/">Algorithms</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-03-19-selection-sort" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/19/2015-03-19-selection-sort/" class="article-date">
  	<time datetime="2015-03-19T04:00:00.000Z" itemprop="datePublished">2015-03-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/19/2015-03-19-selection-sort/">选择排序（selection sort）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="基本思想">基本思想</h3><p>每次遍历待排序序列，选出最大或最小的元素移到已排序序列对头或队尾</p>
<h3 id="选择排序种类">选择排序种类</h3><ol>
<li><strong>简单选择排序</strong>：通过遍历数组来排序</li>
<li><strong>堆排序</strong>：通过堆来排序</li>
</ol>
<h3 id="伪代码（简单选择排序）">伪代码（简单选择排序）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECTION-SORT(A)</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to A.length - <span class="number">1</span></span><br><span class="line">        min = i</span><br><span class="line">        <span class="keyword">for</span> j = i + <span class="number">1</span> to A.length // 遍历选择最小元素</span><br><span class="line">            <span class="keyword">if</span> A[min] &gt; A[j]</span><br><span class="line">                min = j</span><br><span class="line">        <span class="keyword">if</span> min != i</span><br><span class="line">            exchange A[min] with A[i]</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$T(n) = O(n^2)$</p>
<p>选择排序不是稳定的排序算法，并且通常选择排序比冒泡排序更快。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/">Algorithms</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-03-18-greedy-algorithm" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/18/2015-03-18-greedy-algorithm/" class="article-date">
  	<time datetime="2015-03-18T13:31:00.000Z" itemprop="datePublished">2015-03-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/18/2015-03-18-greedy-algorithm/">贪心算法（greedy algorithm）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>贪心算法</strong>是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。</p>
<p>这种启发式策略不是对所有问题都能得到整体最优解，关键是<strong>贪心策略</strong>的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。</p>
<h3 id="贪心算法的基本思路">贪心算法的基本思路</h3><ol>
<li>建立数学模型来描述问题</li>
<li>把求解的问题分成若干个子问题</li>
<li>对每个子问题求解，得到子问题的局部最优解</li>
<li>把子问题的局部最优解合成原问题的一个解</li>
</ol>
<h3 id="贪心算法的关键性质">贪心算法的关键性质</h3><ol>
<li><strong>贪心选择性质</strong>（greedy-choice property）<br>可以通过局部最优（贪心）选择来构造全局最优解，即进行选择时，直接做出在当前问题中看起来最优的选择，而不必考虑子问题的解。<br>（在动态规划中选择通常依赖于子问题的解，而贪心算法进行选择时可能依赖之前做出的选择，但不依赖任何将来的选择或是子问题的解，因此，与动态规划先求解子问题才能进行第一次选择不同，贪心算法在进行第一次选择之前不求解任何子问题。）</li>
<li><strong>最优子结构性质</strong><br>子问题的最优解与贪心选择组合在一起能生成原问题的最优解。</li>
</ol>
<h3 id="相关问题">相关问题</h3><p>活动选择问题<br>赫夫曼编码<br>拟阵</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/">Algorithms</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-03-18-quick-sort" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/18/2015-03-18-quick-sort/" class="article-date">
  	<time datetime="2015-03-18T09:00:00.000Z" itemprop="datePublished">2015-03-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/18/2015-03-18-quick-sort/">快速排序（quick sort）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>快速排序</strong>，又称<strong>分区交换排序</strong>，是对冒泡排序的一种改进。快速排序是<strong>分治策略</strong>的一个典型应用。</p>
<h3 id="快速排序步骤">快速排序步骤</h3><ol>
<li><strong>分解</strong>：PARTITION(A, s, e)，将原问题分解为两个子问题（$O(n)$）</li>
<li><strong>解决</strong>：QUICK-SORT(A, s, e)，递归求解子问题（$O(nlgn)$）</li>
<li><strong>合并</strong>：不需要</li>
</ol>
<h3 id="图示">图示</h3><p><img src="/images/2015-03-18/quick-sort.png" alt="快速排序划分"></p>
<h3 id="伪代码">伪代码</h3><p><strong>普通版本：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PARTITION(A, s, e)</span><br><span class="line">    x = A[e]</span><br><span class="line">    i = s - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j = s to e - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> A[j] &lt;= x</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">            exchange A[i] with A[j]</span><br><span class="line">    exchange A[i + <span class="number">1</span>] with A[r]</span><br><span class="line">    <span class="built_in">return</span> i + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QUICK-SORT(A, s, e)</span><br><span class="line">    <span class="keyword">if</span> s &lt; e</span><br><span class="line">        q = PARTITION(A, s, e) // 分解</span><br><span class="line">        QUICK-SORT(A, s, q - <span class="number">1</span>) // 解决</span><br><span class="line">        QUICK-SORT(A, q + <span class="number">1</span>, e) // 解决</span><br></pre></td></tr></table></figure>
<p><strong>随机化版本：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RANDOMIZED-PARTITION(A, s, e)</span><br><span class="line">    i = RANDOM(s, e)</span><br><span class="line">    exchange A[e] with A[i]</span><br><span class="line">    <span class="built_in">return</span> PARTITION(A, s, e)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RANDOMIZED-QUICK-SORT(A, s, e)</span><br><span class="line">    <span class="keyword">if</span> s &lt; e</span><br><span class="line">        q = RANDOMIZED-PARTITION(A, s, e) // 分解</span><br><span class="line">        RANDOMIZED-QUICK-SORT(A, s, q - <span class="number">1</span>) // 解决</span><br><span class="line">        RANDOMIZED-QUICK-SORT(A, q + <span class="number">1</span>, e) // 解决</span><br></pre></td></tr></table></figure>
<p>时间复杂度（期望）：$T(n) = O(nlgn)$</p>
<p>快速排序的平均性能非常好，而且是原址排序，通常是实际排序应用中最好的选择。但快速排序不是稳定的算法。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/">Algorithms</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-03-18-merge-sort" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/18/2015-03-18-merge-sort/" class="article-date">
  	<time datetime="2015-03-18T07:00:00.000Z" itemprop="datePublished">2015-03-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/18/2015-03-18-merge-sort/">归并排序（merge sort）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>归并排序</strong>是创建在归并操作上的一种有效的排序算法。该算法是<strong>分治策略</strong>的一个非常典型的应用。</p>
<h3 id="归并排序步骤">归并排序步骤</h3><ol>
<li><strong>分解</strong>：将原问题分解为两个规模相同的子问题（$O(1)$）</li>
<li><strong>解决</strong>：递归求解子问题（$O(nlgn)$）</li>
<li><strong>合并</strong>（归并操作）：MERGE(A, s, q, e)，合并子问题的解为原问题的解（$O(n)$）</li>
</ol>
<h3 id="归并操作">归并操作</h3><p>归并操作（merge）指将两个已经排序的序列合并为一个序列操作。</p>
<p>归并操作过程如下：</p>
<ol>
<li>申请空间，以保存合并后的序列</li>
<li>设两个指针分别指向两个排序序列的起始位置</li>
<li>比较指针指向的元素，选择较小的放入合并序列，并移动指针到下一位置</li>
<li>重复3直到某一指针到达列尾</li>
<li>将另一序列剩下的元素复制到合并序列</li>
</ol>
<h3 id="图示">图示</h3><p><img src="/images/2015-03-18/merge-sort.png" alt="merge"></p>
<h3 id="伪代码">伪代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MERGE-SORT(A, s, e)</span><br><span class="line">    <span class="keyword">if</span> s &lt; e</span><br><span class="line">        q = (s + e) / <span class="number">2</span> // 分解</span><br><span class="line">        MERGE-SORT(A, s, q) // 解决</span><br><span class="line">        MERGE-SORT(A, q + <span class="number">1</span>, e) // 解决</span><br><span class="line">        MERGE(A, s, q, e) // 合并</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MERGE(A, s, q, e)</span><br><span class="line">    n1 = q - s + <span class="number">1</span></span><br><span class="line">    n2 = e - q</span><br><span class="line">    <span class="built_in">let</span> L[<span class="number">1</span>..n1+<span class="number">1</span>] and R[<span class="number">1</span>..n2+<span class="number">1</span>] be new array</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to n1 // 复制排序序列A</span><br><span class="line">        L[i] = A[s + i - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span> to n2 // 复制排序序列B</span><br><span class="line">        R[j] = A[q + j]</span><br><span class="line">    L[n1 + <span class="number">1</span>] = infty</span><br><span class="line">    L[n2 + <span class="number">1</span>] = infty</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k = s to e // 将排序序列A,B复制到合成序列</span><br><span class="line">        <span class="keyword">if</span> L[i] &lt;= R[j]</span><br><span class="line">            A[k] = L[i]</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            A[k] = R[j]</span><br><span class="line">            j = j + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度：$T(n) = 2T(n/2) + cn = O(nlgn)$</p>
<p>归并排序是个稳定的算法，但需要$O(n)$的额外空间。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/">Algorithms</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-03-18-linear-list" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/18/2015-03-18-linear-list/" class="article-date">
  	<time datetime="2015-03-18T05:00:00.000Z" itemprop="datePublished">2015-03-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/18/2015-03-18-linear-list/">线性表（linear list）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>线性表</strong>是一个线性结构，由n（n≥0）个数据元素（结点）a[0]，a[1]，a[2]，…，a[n-1]组成的有限序列。</p>
<p>线性表的逻辑结构简单，便于实现和操作。因此，线性表在实际应用中被广泛采用的一种数据结构。</p>
<h3 id="线性表的作用">线性表的作用</h3><p>在实际应用中，线性表都是以<strong>栈</strong>、<strong>队列</strong>、<strong>字符串</strong>、<strong>数组</strong>等特殊线性表的形式来使用。</p>
<h3 id="线性表的特征">线性表的特征</h3><ol>
<li>集合中必存在唯一的一个“第一元素”</li>
<li>集合中必存在唯一的一个“最后元素” </li>
<li>除最后一个元素之外，均有唯一的后继(后件)</li>
<li>除第一个元素之外，均有唯一的前驱(前件)</li>
</ol>
<h3 id="线性表的存储结构">线性表的存储结构</h3><ol>
<li><strong>顺序存储结构</strong>：顺序表（物理上连续）</li>
<li><strong>链式存储结构</strong>：链表（物理上不连续，逻辑上连续）</li>
</ol>
<h3 id="线性表的模型">线性表的模型</h3><p><img src="/images/2015-03-18/linear-list.png" alt="快速排序划分"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structures/">Data Structures</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-03-17-queue" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/17/2015-03-17-queue/" class="article-date">
  	<time datetime="2015-03-17T07:16:00.000Z" itemprop="datePublished">2015-03-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/17/2015-03-17-queue/">队列（queue）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>队列</strong>是一种动态集合，并且限定了动态集合的DELETE操作所移除的元素是最先插入的元素。栈实现的是一种<strong>先进先出</strong>（first-in，first-out，FIFO）的策略。</p>
<p>队列可视为一种<strong>线性表</strong>，通过限定在线性表的前端进行插入，在后端进行删除操作来实现FIFO。</p>
<h3 id="队列的作用">队列的作用</h3><p>队列可以用于对序列实行顺序操作。</p>
<h3 id="队列的操作">队列的操作</h3><ol>
<li>ENQUEUE(Q, x)： 入队（$O(1)$）</li>
<li>DEQUEUE(Q)： 出队（$O(1)$）</li>
</ol>
<h3 id="队列的模型">队列的模型</h3><p><img src="/images/2015-03-17/queue.png" alt="队列的模型"></p>
<h3 id="队列的实现">队列的实现</h3><ol>
<li><strong>顺序队列</strong>：使用数组实现，设head和tail指针分别指向队头和队尾，在队尾进行插入操作，在队头进行删除操作</li>
<li><strong>链式队列</strong>：使用链表实现，设head和tail指针分别指向队头和队尾，在队尾进行插入操作，在队头进行删除操作</li>
</ol>
<h3 id="伪代码（使用数组实现）">伪代码（使用数组实现）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ENQUEUE(Q, x)</span><br><span class="line">    Q[Q.tail] = x</span><br><span class="line">    <span class="keyword">if</span> Q.tail == Q.length</span><br><span class="line">        Q.tail = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> Q.tail = Q.tail + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DEQUEUE(Q)</span><br><span class="line">    x = Q[Q.head]</span><br><span class="line">    <span class="keyword">if</span> Q.head == Q.length</span><br><span class="line">        Q.head = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> Q.head = Q.head + <span class="number">1</span></span><br><span class="line">    <span class="built_in">return</span> x</span><br></pre></td></tr></table></figure>
<h3 id="双端队列">双端队列</h3><p>具有队列和栈性质的数据结构，双端队列的插入和删除操作可以在两端进行。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structures/">Data Structures</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-03-17-stack" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/17/2015-03-17-stack/" class="article-date">
  	<time datetime="2015-03-17T06:13:00.000Z" itemprop="datePublished">2015-03-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/17/2015-03-17-stack/">栈（stack）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>栈</strong>又名堆栈，它是一种动态集合，并且限定了动态集合的DELETE操作所移除的元素是最近插入的元素。栈实现的是一种<strong>后进先出</strong>（last-in，first-out，LIFO）的策略。</p>
<p>栈可视为一种<strong>线性表</strong>，通过限定在线性表的一端进行插入和删除操作来实现LIFO。</p>
<h3 id="栈的作用">栈的作用</h3><p>栈可以用于对序列实行逆序操作，也就是说栈具有<strong>记忆</strong>的能力，这种能力在计算机系统中应用十分广泛（比如<strong>堆栈帧</strong>）。</p>
<h3 id="栈的操作">栈的操作</h3><ol>
<li>STACK-EMPTY(S)： 判断栈空（$O(1)$）</li>
<li>PUSH(S, x)： 压栈（$O(1)$）</li>
<li>POP(S)： 出栈（$O(1)$）</li>
</ol>
<h3 id="栈的模型">栈的模型</h3><p><img src="/images/2015-03-17/stack.png" alt="栈的模型"></p>
<h3 id="栈的实现">栈的实现</h3><ol>
<li><strong>顺序栈</strong>：使用数组实现，设top指针指向栈顶，在栈顶进行操作</li>
<li><strong>链式栈</strong>：使用链表实现，在头指针head后面进行操作</li>
</ol>
<h3 id="伪代码（使用数组实现）">伪代码（使用数组实现）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STACK-EMPTY(S)</span><br><span class="line">    <span class="keyword">if</span> S.top == <span class="number">0</span></span><br><span class="line">        <span class="built_in">return</span> TRUE</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">return</span> FALSE</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUSH(S, x)</span><br><span class="line">    S.top = S.top + <span class="number">1</span></span><br><span class="line">    S[S.top] = x</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POP(S)</span><br><span class="line">    <span class="keyword">if</span> STACK-EMPTY(S)</span><br><span class="line">        error <span class="string">"underflow"</span></span><br><span class="line">    <span class="keyword">else</span> S.top = S.top - <span class="number">1</span></span><br><span class="line">        <span class="built_in">return</span> S[S.top + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="相关知识">相关知识</h3><p>堆栈帧</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structures/">Data Structures</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-03-17-dynamic-programming" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/17/2015-03-17-dynamic-programming/" class="article-date">
  	<time datetime="2015-03-16T16:27:00.000Z" itemprop="datePublished">2015-03-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/17/2015-03-17-dynamic-programming/">动态规划（dynamic programming）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>动态规划</strong>（DP）是运筹学的一个分支，是求解<strong>决策过程</strong>（decision process）最优化的数学方法。</p>
<h3 id="基本思想">基本思想</h3><p>将过程分成若干个相互联系的阶段，即子问题，将各个阶段按照一定的次序排列好之后，对某个给定的阶段状态，先求解子问题，然后从这些子问题的解得到原问题的解，对于重复出现的子问题，只在第一次遇到时对其求解，并保持起来，让以后再次遇到时可以直接引用。</p>
<p>动态规划和分治策略类似，其最大的区别在于：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）</p>
<h3 id="相关概念">相关概念</h3><ul>
<li><p><strong>多阶决策过程</strong><br>有一类活动的过程，由于它的特殊性，可将过程分成若干相互联系的阶段，在它的每一阶段都要做出决策，从而使整个过程达到最好的活动效果，这种把一个问题看做是一个前后关联具有链状结构的多阶段过程，称之为多阶段决策过程。</p>
</li>
<li><p><strong>动态规划</strong><br>在多阶段决策问题中，各个阶段采取的决策，一般来说是跟是时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有”动态“的含义，这种解决多阶段决策最优化的过程，称之为动态规划。</p>
</li>
<li><p><strong>最优化原理</strong><br>一个过程的最优决策具有这样的性质：即无论其初始状态和初始决策如何，其今后诸策略对以第一个决策所形成的状态作为初始状态的过程而言，必须构成最优策略。简言之，一个最优策略的子策略，对于它的初态和终态而言也必是最优的</p>
</li>
</ul>
<p>动态规划通常用来求解<strong>最优化问题</strong>（optimization problem），适用动态规划的最优化问题一般具备以下三个性质：</p>
<ol>
<li><strong>最优子结构性质</strong>：问题的最优解包含了子问题的最优解，即满足最优化原理</li>
<li><strong>无后效性</strong>：某阶段状态一旦确定，就不受这个状态以后决策的影响</li>
<li><strong>重叠子问题性质</strong>：子问题之间不是相互独立的，一个子问题在下一阶段决策中可能被多次使用。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）<br>动态规划实质上是一种以空间换时间的技术，是<strong>时空权衡</strong>（time-memory trade-off）的一个典型案例。</li>
</ol>
<p>最优子结构的影响因素：</p>
<ol>
<li>原问题的最优解涉及了多少个子问题</li>
<li>在通过子问题确定最优解时，我们需要考察多少种选择</li>
</ol>
<p>原问题最优解的代价通常就是子问题最优解的代价加上对子问题作出选择的代价</p>
<h3 id="动态规划算法">动态规划算法</h3><p>动态规划处理的问题是一个多阶段决策问题，其过程如下所示：<br><img src="/images/2015-03-17/decision_process.png" alt="多阶段决策"></p>
<p>一般步骤：</p>
<ol>
<li>划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解</li>
<li>确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</li>
<li>确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</li>
<li>寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</li>
</ol>
<p>一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。</p>
<p>简化步骤：</p>
<ol>
<li>刻画最优解的结构特征</li>
<li>递归定义最优解的值</li>
<li>计算最优解的值（带备忘的自顶向下或自底向上）</li>
<li>利用计算的信息构造一个最优解</li>
</ol>
<h3 id="动态规划实现方法">动态规划实现方法</h3><ol>
<li><strong>自顶向下（带备忘）</strong>：<br>递归形式下保存每个子问题的解（备忘），当需要子问题的解时查询保存的解，若没有保存的解则求解子问题。</li>
<li><strong>自底向上</strong>：<br>先求解粒度小的子问题并保存子问题的解，再在此基础上求解粒度更大的问题，直到解决原问题。</li>
</ol>
<p>带备忘的自顶向下和自底向上两种方法渐进时间相同，但自底向上的时间复杂性通常具有更小的系数（不需要递归调用的开销）</p>
<h3 id="相关问题">相关问题</h3><p>钢条切割问题<br>矩阵链乘法问题<br>最长公共子序列<br>最优二叉搜索树</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/">Algorithms</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-03-17-divide-and-conquer" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/17/2015-03-17-divide-and-conquer/" class="article-date">
  	<time datetime="2015-03-16T16:06:00.000Z" itemprop="datePublished">2015-03-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/17/2015-03-17-divide-and-conquer/">分治策略（divide and conquer）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>分治策略</strong>是建基于多项分支递归的一种很重要的算法范式。</p>
<h3 id="基本思想">基本思想</h3><p>分治策略的基本思想就是“分而治之”，把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</p>
<p>分治法适用问题一般具备以下几个特征：</p>
<ol>
<li>问题规模缩小到一定程度可以容易地求解</li>
<li>问题可以分解为若干个规模较小的子问题（最优子结构性质）</li>
<li>子问题的解可以合并为原问题的解</li>
<li>子问题之间相互独立</li>
</ol>
<p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加。<br>第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用。<br>第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。<br>第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。</p>
<h3 id="基本步骤">基本步骤</h3><ul>
<li><strong>分解</strong>：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题</li>
<li><strong>解决</strong>：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</li>
<li><strong>合并</strong>：将各个子问题的解合并为原问题的解</li>
</ul>
<h3 id="算法分析">算法分析</h3><p>递归式可以很自然地刻画分治算法的运行时间。</p>
<p>求解递归式的方法：</p>
<ul>
<li>代入法</li>
<li>递归树法</li>
<li>主方法</li>
</ul>
<h3 id="相关问题">相关问题</h3><p>归并排序<br>快速排序<br>最大子数组问题<br>Strassen矩阵乘法</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/">Algorithms</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-03-16-bubble-sort" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/16/2015-03-16-bubble-sort/" class="article-date">
  	<time datetime="2015-03-16T02:06:00.000Z" itemprop="datePublished">2015-03-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/16/2015-03-16-bubble-sort/">冒泡排序（bubble sort）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="基本思想">基本思想</h3><p>通过相邻元素两两比较将最大或最小的元素往上浮，直到排序完成。</p>
<h3 id="伪代码">伪代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BUBBLE-SORT(A)</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to A.length - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j = A.length downto i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> A[j] &lt; A[j - <span class="number">1</span>]</span><br><span class="line">                exchange A[j] with A[j - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$T(n) = O(n^2)$</p>
<p>冒泡排序是个稳定的排序算法，但效率比较低。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/">Algorithms</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-03-10-insertion sort" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/10/2015-03-10-insertion sort/" class="article-date">
  	<time datetime="2015-03-10T04:00:00.000Z" itemprop="datePublished">2015-03-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/10/2015-03-10-insertion sort/">插入排序（insertion sort）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="基本思想：">基本思想：</h3><p>从一堆乱序的序列中依次抽取一个数，从后往前扫描已排序序列，将抽取的数插入已排序序列相应位置（相当于给乱序的扑克牌排序）</p>
<h3 id="伪代码：">伪代码：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INSERTION-SORT(A)</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">2</span> to A.length</span><br><span class="line">        key = A[j]</span><br><span class="line">        i = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> and A[i] &gt; key</span><br><span class="line">            A[i + <span class="number">1</span>] = A[i]</span><br><span class="line">            i = i - <span class="number">1</span></span><br><span class="line">        A[i + <span class="number">1</span>] = key</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$T(n) = O(n^2)$</p>
<p>插入排序是个稳定的排序算法，当输入规模比较小时，插入排序是个不错的选择。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/">Algorithms</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Programming/">Programming</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-02-19-homogeneous-coordinates" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/02/19/2015-02-19-homogeneous-coordinates/" class="article-date">
  	<time datetime="2015-02-19T07:00:00.000Z" itemprop="datePublished">2015-02-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/19/2015-02-19-homogeneous-coordinates/">齐次坐标</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近看游戏引擎的书，经常会触及<strong>齐次坐标</strong>（homogeneous coordinates）这个概念，但往往总是对此一笔带过，搞得我总是一知半解，以前学线性代数时应该也接触过这个概念，不过现在对其中的细节已经淡忘了。</p>
<p>要了解齐次坐标必须先了解<strong>仿射变换</strong>（affine transformation）和<strong>线性变换</strong>（linear transformation）。所谓线性变换，是指两个向量之间的转换，其保持了向量加法和向量乘法的运算。</p>
<p>简而言之，线性变换必须满足下面两个条件：<br>可加性：$f(v_a + v_b) = f(v_a) + f(v_b)$<br>齐次性：$f(kv) = kf(v)$<br>而平移变换（$f(v) = v + t$）不满足上述条件，所以平移变换不是线性变换。</p>
<p>正因为线性变换不能表示平移变换，所以引入了仿射空间和仿射变换（具体描述见<a href="http://www.fuzihao.org/blog/2014/10/23/%E4%BB%BF%E5%B0%84%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/" target="_blank" rel="external">仿射空间与仿射变换</a>），仿射空间简言之就是没有原点的向量空间，因为没有原点，所以定义了一个仿射组合来消除原点的影响。<br>通过仿射组合我们可以将仿射变换表示为线性变换和平移变换的叠加形式：<br>$$y = Ax + b$$</p>
<p>齐次坐标其实就是将n维的向量用n+1维来表示，这种表示方法使得平移变换可以通过矩阵来表示，上面的仿射变换可以用齐次坐标表示为：<br>$$<br>\begin{bmatrix}y\\1\end{bmatrix} = \begin{bmatrix}A&amp;b\\0&amp;1\end{bmatrix}\cdot\begin{bmatrix}x\\1\end{bmatrix}<br>$$</p>
<p>考虑当第n+1维为0时：</p>
<p>$$<br>\begin{bmatrix}y\\0\end{bmatrix} = \begin{bmatrix}A&amp;b\\0&amp;1\end{bmatrix}\cdot\begin{bmatrix}x\\0\end{bmatrix}<br>$$</p>
<p>上式相当于线性变换：<br>$$y = Ax$$<br>所以齐次坐标的第n+1维的取值决定了是否进行平移变换，借此可以用来区分点和向量的变换。</p>
<p>最后还有一个问题：齐次坐标的齐次究竟是什么意思？我想了很久也想不通其中的深意。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Math/">Math</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Base/">Base</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 Benny Wong
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/mobile.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-60847492-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->




<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  </div>
</body>
</html>